// FieldOfVsion.cpp

#define _USE_MATH_DEFINES

#include <iostream>
#include <fstream>
#include <math.h>

using namespace std;

// Enum definition
enum TerrainType
{
	EMPTY   = 'O',
	BARRIER = 'x',
	HIDDEN  = 'H',
	WALL    = 'W'
};

// Struct definition
struct Direction
{
	int nRowMov;
	int nColMov;
};

struct Location
{
	int nRow;
	int nCol;
};

// Global const definition
const int MAP_SIZE = 11;
const int WALL_SIZE = 1;
const int MATRIX_SIZE = MAP_SIZE + (WALL_SIZE * 2);
const int DIRECTION_NUM = 8;
const Direction MOVEMENT_VEC[DIRECTION_NUM] = {{-1, 0},
											   {-1, 1},
											   {0, 1},
											   {1, 1},
											   {1, 0},
											   {1, -1},
											   {0, -1},
											   {-1, -1}};

// Function prototype
void InitMatrix(TerrainType oarrttInitMat[MATRIX_SIZE][MATRIX_SIZE]);
bool ReadMatrixFromFile(TerrainType ioarrttMap[MATRIX_SIZE][MATRIX_SIZE],
	                    const char* DATA_FILE_NAME);
void ScanRadius(TerrainType ioarrttMap[MATRIX_SIZE][MATRIX_SIZE],
	            int         inRadiusToScan);
bool WriteMatrixToFile(TerrainType iarrttMap[MATRIX_SIZE][MATRIX_SIZE],
	                   const char* DATD_FILE_NAME);
int FindDirection(Location* iplocBarrierLocation);
double Vang(int nX, int nY);
void MakeHidden(TerrainType ioarrttMap[MATRIX_SIZE][MATRIX_SIZE],
	            Location ilocBarrierLoc);
bool MakeSideHidde(TerrainType ioarrttMap[MATRIX_SIZE][MATRIX_SIZE],
	               Location    ilocVisionLoc,
	               int         inMaxCells,
	               Direction   idirMoveDir);

//---------------------------------------------------------------------------------------
//                                          FieldOfVision
//                                          -------------
// 
// General  : The program gets barriers location on a map, and calculates the field
//            of vision for a troop location in the middle of map.
//
// Input    : The barriers locations (by rows and cols). the information is taken 
//            from data file.
//
// Process  : The program calculates the line of sight which is interrupted by the 
//            barriers.
//
// Output   : A data file with a map that shows the field of vision for the troop.
//
//---------------------------------------------------------------------------------------
// Programmer :
// Stud No    :
// Date       : 
//---------------------------------------------------------------------------------------
void main()
{
	// Const definition
	const char szReadFileName[] = "Terrain.dat";
	const char szSaveFileName[] = "FieldOfVision.dat";

	// Array definition
	TerrainType arrttVisionMap[MATRIX_SIZE][MATRIX_SIZE];

	// Variable definition
	int nRadiusIndex;

	// Code section

	// Initializing the map 
	InitMatrix(arrttVisionMap);

	// Checks if file was opened successfully
	if (!ReadMatrixFromFile(arrttVisionMap, szReadFileName))
	{
		cout << "Barriers data file coldn't opened" << endl;
	}
	else
	{
		// Scans all the map for barriers
		for (nRadiusIndex = 1; nRadiusIndex <= MAP_SIZE; nRadiusIndex++)
		{
			ScanRadius(arrttVisionMap, nRadiusIndex);
		}

		// Checks if file was opened successfully
		if (!WriteMatrixToFile(arrttVisionMap, szSaveFileName))
		{
			cout << "Save data file couldn't opened" << endl;
		}
		else
		{
			cout << "Save data successfuly!" << endl;
		}
	}
}

//---------------------------------------------------------------------------------------
//                                          Init Mattrix
//                                          ------------
//
// General      : Initialize the map matrix in with a wall in the corrners and 
//                the interior with empty squares
//
// Parameters   : 
//		oarrttInitMat - The matrix to be initialized [out]
//
// Return Value : None.
//
//---------------------------------------------------------------------------------------
void InitMatrix(TerrainType oarrttInitMat[MATRIX_SIZE][MATRIX_SIZE])
{
	// Variable definition
	int nRowIndex;
	int nColIndex;

	// Code section

	// Runs over all the rows 
	for (nRowIndex = 0; nRowIndex < MATRIX_SIZE; nRowIndex++)
	{
		// Runs over all the cols and initialize each cell as WALL
		for (nColIndex = 0; nColIndex < MATRIX_SIZE; nColIndex++)
		{
			oarrttInitMat[nRowIndex][nColIndex] = WALL;
		}
	}

	// Runs over the rows of the map itself 
	for (nRowIndex = WALL_SIZE; nRowIndex <= MAP_SIZE; nColIndex++)
	{
		// Runs over the cols of the map itself and initialize each cell whith EMPTY
		for (nColIndex = WALL_SIZE; nColIndex < MAP_SIZE; nColIndex++)
		{
			oarrttInitMat[nRowIndex][nColIndex] = EMPTY;
		}
	}
}

//---------------------------------------------------------------------------------------
//                               Read Mattrix From File
//                               ----------------------
//
// General      : 
//
// Parameters   :
//
// Return Value : None.
//
//---------------------------------------------------------------------------------------
bool ReadMatrixFromFile(TerrainType ioarrttMap[MATRIX_SIZE][MATRIX_SIZE],
	                    const char* DATA_FILE_NAME)
{
	// File definition
	fstream fsDataFile;

	// Variable definition
	bool bIsOpen = false;
	Location locCurrentBarrier;

	// Code section

	fsDataFile.open(DATA_FILE_NAME, ios::in);

	// Check if file is open 
	if (fsDataFile.is_open())
	{
		bIsOpen = true;

		// Getts row of barrier
		fsDataFile >> locCurrentBarrier.nRow;

		// Runs until reaching the end of file 
		while (!fsDataFile.eof())
		{
			// Gets Col of a barrier
			fsDataFile >> locCurrentBarrier.nCol;

			// Places the barrier in the map
			ioarrttMap[locCurrentBarrier.nRow + WALL_SIZE - 1][locCurrentBarrier.nCol +
				                                               WALL_SIZE - 1] = BARRIER;

			// Gets next row of a barrier
			fsDataFile >> locCurrentBarrier.nRow;
		}

		fsDataFile.close();
	}

	return (bIsOpen);
}

//---------------------------------------------------------------------------------------
//                                   Scan Radius
//                                   -----------
//
// General      : 
//
// Parameters   :
//
// Return Value : None.
//
//---------------------------------------------------------------------------------------
void ScanRadius(TerrainType ioarrttMap[MATRIX_SIZE][MATRIX_SIZE],
	            int         inRadiusToScan)
{
	// Const definition
	const Location locMiddle       = { MATRIX_SIZE / 2, MATRIX_SIZE / 2 };
	const int nSatrtingCornerIndex = 5;

	// Variable definition
	int nSideIndex;
	int nCellIndex;
	int nMovementIndex = (nSatrtingCornerIndex + 3) % DIRECTION_NUM;
	Direction dirCurrentDir = MOVEMENT_VEC[nMovementIndex];
	Location locCurrentLoc = {locMiddle.nRow +
							  (MOVEMENT_VEC[nSatrtingCornerIndex].nRowMov *
							   inRadiusToScan),
							  locMiddle.nCol +
							  (MOVEMENT_VEC[nSatrtingCornerIndex].nColMov *
							   inRadiusToScan)};

	// Code section

	// Goes over each side of the radius 
	for (nSideIndex = 0; nSideIndex < 4; nSideIndex++)
	{
		// Goes over current side 
		for (nCellIndex = 0; nCellIndex < inRadiusToScan * 2; nCellIndex++)
		{
			// Checks if cell is barrier
			if (ioarrttMap[locCurrentLoc.nRow][locCurrentLoc.nCol] == BARRIER)
			{
				MakeHidden(ioarrttMap, locCurrentLoc);
			}

			// Goes to the next cell 
			locCurrentLoc.nRow += dirCurrentDir.nRowMov;
			locCurrentLoc.nCol += dirCurrentDir.nColMov;
		}

		// Change movement direction 
		nMovementIndex = (nMovementIndex + 2) % DIRECTION_NUM;
		dirCurrentDir  = MOVEMENT_VEC[nMovementIndex];
	}
}

//---------------------------------------------------------------------------------------
//                                   Write Matrix To File
//                                   --------------------
//
// General      : 
//
// Parameters   :
//
// Return Value : None.
//
//---------------------------------------------------------------------------------------
bool WriteMatrixToFile(TerrainType iarrttMap[MATRIX_SIZE][MATRIX_SIZE],
	                   const char* DATD_FILE_NAME)
{
	// File definition
	fstream fsDataFile;

	// Variable defintion
	int  nRowIndex;
	int  nColIndex;
	bool bIsOpen = false;

	// Code sction

	fsDataFile.open(DATD_FILE_NAME, ios::out);

	// Checks if file is open
	if (fsDataFile.is_open())
	{
		bIsOpen = true;

		// Runs over the map and in the data file 
		for (nRowIndex = WALL_SIZE; nRowIndex <= MAP_SIZE; nRowIndex++)
		{
			for (nColIndex = WALL_SIZE; nColIndex <= MAP_SIZE; nColIndex++)
			{
				fsDataFile << (char)iarrttMap[nRowIndex][nColIndex] << "\t";
			}

			fsDataFile << endl;
		}

		fsDataFile.close();
	}

	return (bIsOpen);
}

//---------------------------------------------------------------------------------------
//                                     Find Direction
//                                     --------------
//
// General      : 
//
// Parameters   :
//
// Return Value : None.
//
//---------------------------------------------------------------------------------------
int FindDirection(Location* iplocBarrierLocation)
{
	// Const definition
	const Location locMiddle = { MATRIX_SIZE / 2, MATRIX_SIZE / 2 };

	// Variable defintion
	double dBarrierAngle;
	int    nRemainder;
	int    nDirectionIndex;

	// Code section

	dBarrierAngle = Vang(iplocBarrierLocation->nCol - locMiddle.nCol,
		                 locMiddle.nRow - iplocBarrierLocation->nRow);
	nDirectionIndex = (int)(dBarrierAngle / 45);
	nRemainder = (int)dBarrierAngle % 90;

	// Checks if a fix is needed
	if ((nRemainder != 0) && (nRemainder < 45))
	{
		nDirectionIndex++;
	}

	return (nDirectionIndex);
}

//---------------------------------------------------------------------------------------
//                                     Vang
//                                     ----
//
// General      : 
//
// Parameters   :
//
// Return Value : None.
//
//---------------------------------------------------------------------------------------
double Vang(int nX, int nY)
{
	// Variable definition
	int    nBaseAngle;
	double dAngle;
	double dReaultAngle;

	// Code section

	// If x is zero
	if (nX == 0)
	{
		// Checking wheather the barrier is above or below the middle
		if (nY > 0)
		{
			;
		}
	}

	return (dReaultAngle);
}

//---------------------------------------------------------------------------------------
//                                     Make Hidden
//                                     -----------
//
// General      : 
//
// Parameters   :
//
// Return Value : None.
//
//---------------------------------------------------------------------------------------
void MakeHidden(TerrainType ioarrttMap[MATRIX_SIZE][MATRIX_SIZE], Location ilocBarrierLoc)
{
	// Variable definiton
	bool     bIsPluseDirStillGoing = true;
	bool     bIsMinusDirStillGoing = true;
	Location locMainVision         = { ilocBarrierLoc.nRow, ilocBarrierLoc.nCol };
	int      nBrrierDirectionIndex = FindDirection(&ilocBarrierLoc);
	int      nCellsCounter         = 0;

	// Code section

	locMainVision.nRow += MOVEMENT_VEC[nBrrierDirectionIndex].nRowMov;
	locMainVision.nCol += MOVEMENT_VEC[nBrrierDirectionIndex].nColMov;

	// Goes until the main line of sight hits a wall
	while (ioarrttMap[locMainVision.nRow][locMainVision.nCol] != WALL)
	{
		ioarrttMap[locMainVision.nRow][locMainVision.nCol] = HIDDEN;
		nCellsCounter++;

		// Checks if the plus direction should go again or finished
		if (bIsPluseDirStillGoing)
		{
			bIsPluseDirStillGoing = MakeSideHidde(ioarrttMap,
				                                  locMainVision,
				                                  nCellsCounter,
				                                  MOVEMENT_VEC[(nBrrierDirectionIndex +
				                                  	            1) % DIRECTION_NUM]);
		}

		// Checks if the minus direction should go again or finished 
		if (bIsMinusDirStillGoing)
		{
			bIsMinusDirStillGoing = MakeSideHidde(ioarrttMap,
				                                  locMainVision,
				                                  nCellsCounter,
				                                  MOVEMENT_VEC[(nBrrierDirectionIndex -
					                                            1 + DIRECTION_NUM) % 
				                                                DIRECTION_NUM]);
		}

		// Gous to next cell in the main vision direction
		locMainVision.nRow += MOVEMENT_VEC[nBrrierDirectionIndex].nRowMov;
		locMainVision.nCol += MOVEMENT_VEC[nBrrierDirectionIndex].nColMov;
	}
}

//---------------------------------------------------------------------------------------
//                                     Make Side Hidden
//                                     ----------------
//
// General      : 
//
// Parameters   :
//
// Return Value : None.
//
//---------------------------------------------------------------------------------------
bool MakeSideHidde(TerrainType ioarrttMap[MATRIX_SIZE][MATRIX_SIZE],
	               Location    ilocVisionLoc,
	               int         inMaxCells,
	               Direction   idirMoveDir)
{
	// Variable definition
	int  nCellIndex;
	bool bIsStillGoing = true;

	// Code section

	// Run as long as still going (didn't hit the wall or hidden cell) or all the area that
	// should be hidden is hidden
	for (nCellIndex = 0; (nCellIndex < inMaxCells) && (bIsStillGoing); nCellIndex++)
	{
		ilocVisionLoc.nRow += idirMoveDir.nRowMov;
		ilocVisionLoc.nCol += idirMoveDir.nColMov;

		// Checks if hit wall or hidden cell
		if ((ioarrttMap[ilocVisionLoc.nRow][ilocVisionLoc.nCol] == WALL) ||
			(ioarrttMap[ilocVisionLoc.nRow][ilocVisionLoc.nCol] == HIDDEN))
		{
			bIsStillGoing = false;
		}
		else
		{
			ioarrttMap[ilocVisionLoc.nRow][ilocVisionLoc.nCol] = HIDDEN;
		}
	}

	return (bIsStillGoing);
}